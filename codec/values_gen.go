//go:build go1.6
// +build go1.6

// Code generated by codecgen - DO NOT EDIT.

package codec

import (
	"errors"
	codec1978 "github.com/ugorji/go/codec"
	"runtime"
	"strconv"
)

const (
	// ----- content types ----
	codecSelferCcUTF85629 = 1
	codecSelferCcRAW5629  = 255
	// ----- value types used ----
	codecSelferValueTypeArray5629     = 10
	codecSelferValueTypeMap5629       = 9
	codecSelferValueTypeString5629    = 6
	codecSelferValueTypeInt5629       = 2
	codecSelferValueTypeUint5629      = 3
	codecSelferValueTypeFloat5629     = 4
	codecSelferValueTypeNil5629       = 1
	codecSelferBitsize5629            = uint8(32 << (^uint(0) >> 63))
	codecSelferDecContainerLenNil5629 = -2147483648
)

var (
	errCodecSelferOnlyMapOrArrayEncodeToStruct5629 = errors.New(`only encoded map or array can be decoded into a struct`)
)

type codecSelfer5629 struct{}

func codecSelfer5629False() bool { return false }
func codecSelfer5629True() bool  { return true }

func init() {
	if codec1978.GenVersion != 25 {
		_, file, _, _ := runtime.Caller(0)
		ver := strconv.FormatInt(int64(codec1978.GenVersion), 10)
		panic(errors.New("codecgen version mismatch: current: 25, need " + ver + ". Re-generate file: " + file))
	}
}

func (wrapSliceUint64) codecSelferViaCodecgen() {}
func (x wrapSliceUint64) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		z.F.EncSliceUint64V(([]uint64)(x), e)
	} // end block: if x slice == nil
}

func (x *wrapSliceUint64) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	z.F.DecSliceUint64X((*[]uint64)(x), d)
}

func (wrapUint64) codecSelferViaCodecgen() {}
func (x wrapUint64) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	r.EncodeUint(uint64(x))
}

func (x *wrapUint64) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	*x = (wrapUint64)(r.DecodeUint64())
}

func (wrapString) codecSelferViaCodecgen() {}
func (x wrapString) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	r.EncodeString(string(x))
}

func (x *wrapString) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	*x = (wrapString)(z.DecStringZC(r.DecodeStringAsBytes()))
}

func (wrapUint64Slice) codecSelferViaCodecgen() {}
func (x wrapUint64Slice) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encwrapUint64Slice((wrapUint64Slice)(x), e)
	} // end block: if x slice == nil
}

func (x *wrapUint64Slice) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decwrapUint64Slice((*wrapUint64Slice)(x), d)
}

func (StringUint64T) codecSelferViaCodecgen() {}
func (x *StringUint64T) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if z.EncBasicHandle().CheckCircularRef {
		z.EncEncode(x)
		return
	}
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.S))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.U))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"S\"")
			} else {
				r.EncodeString(`S`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.S))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"U\"")
			} else {
				r.EncodeString(`U`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.U))
			z.EncWriteMapEnd()
		}
	}
}

func (x *StringUint64T) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil5629 {
		*(x) = StringUint64T{}
	} else if yyct2 == codecSelferValueTypeMap5629 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray5629 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct5629)
	}
}

func (x *StringUint64T) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := r.DecodeStringAsBytes()
		z.DecReadMapElemValue()
		switch string(yys3) {
		case "S":
			x.S = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
		case "U":
			x.U = (uint64)(r.DecodeUint64())
		default:
			z.DecStructFieldNotFound(-1, string(yys3))
		} // end switch yys3
	} // end for yyj3
}

func (x *StringUint64T) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.S = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.U = (uint64)(r.DecodeUint64())
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *StringUint64T) IsCodecEmpty() bool {
	return !(x.S != "" || x.U != 0 || false)
}

func (AnonInTestStruc) codecSelferViaCodecgen() {}
func (x *AnonInTestStruc) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if z.EncBasicHandle().CheckCircularRef {
		z.EncEncode(x)
		return
	}
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(10)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.AS))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.AI64))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.AI16))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.AUi64))
			z.EncWriteArrayElem()
			if x.AI64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.AI64slice, e)
			} // end block: if x.AI64slice slice == nil
			z.EncWriteArrayElem()
			if x.AUi64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.AUi64slice, e)
			} // end block: if x.AUi64slice slice == nil
			z.EncWriteArrayElem()
			yy19 := &x.AI64arr8
			h.encArray8int64((*[8]int64)(yy19), e)
			z.EncWriteArrayElem()
			yy21 := &x.AI64arr0
			h.encArray0int64((*[0]int64)(yy21), e)
			z.EncWriteArrayElem()
			if x.AI64slice0 == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.AI64slice0, e)
			} // end block: if x.AI64slice0 slice == nil
			z.EncWriteArrayElem()
			if x.AUi64sliceN == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.AUi64sliceN, e)
			} // end block: if x.AUi64sliceN slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(10)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AS\"")
			} else {
				r.EncodeString(`AS`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.AS))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64\"")
			} else {
				r.EncodeString(`AI64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.AI64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI16\"")
			} else {
				r.EncodeString(`AI16`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.AI16))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64\"")
			} else {
				r.EncodeString(`AUi64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.AUi64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64slice\"")
			} else {
				r.EncodeString(`AI64slice`)
			}
			z.EncWriteMapElemValue()
			if x.AI64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.AI64slice, e)
			} // end block: if x.AI64slice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64slice\"")
			} else {
				r.EncodeString(`AUi64slice`)
			}
			z.EncWriteMapElemValue()
			if x.AUi64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.AUi64slice, e)
			} // end block: if x.AUi64slice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64arr8\"")
			} else {
				r.EncodeString(`AI64arr8`)
			}
			z.EncWriteMapElemValue()
			yy31 := &x.AI64arr8
			h.encArray8int64((*[8]int64)(yy31), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64arr0\"")
			} else {
				r.EncodeString(`AI64arr0`)
			}
			z.EncWriteMapElemValue()
			yy33 := &x.AI64arr0
			h.encArray0int64((*[0]int64)(yy33), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64slice0\"")
			} else {
				r.EncodeString(`AI64slice0`)
			}
			z.EncWriteMapElemValue()
			if x.AI64slice0 == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.AI64slice0, e)
			} // end block: if x.AI64slice0 slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64sliceN\"")
			} else {
				r.EncodeString(`AUi64sliceN`)
			}
			z.EncWriteMapElemValue()
			if x.AUi64sliceN == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.AUi64sliceN, e)
			} // end block: if x.AUi64sliceN slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *AnonInTestStruc) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil5629 {
		*(x) = AnonInTestStruc{}
	} else if yyct2 == codecSelferValueTypeMap5629 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray5629 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct5629)
	}
}

func (x *AnonInTestStruc) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := r.DecodeStringAsBytes()
		z.DecReadMapElemValue()
		switch string(yys3) {
		case "AS":
			x.AS = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
		case "AI64":
			x.AI64 = (int64)(r.DecodeInt64())
		case "AI16":
			x.AI16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
		case "AUi64":
			x.AUi64 = (uint64)(r.DecodeUint64())
		case "AI64slice":
			z.F.DecSliceInt64X(&x.AI64slice, d)
		case "AUi64slice":
			z.F.DecSliceUint64X(&x.AUi64slice, d)
		case "AI64arr8":
			h.decArray8int64((*[8]int64)(&x.AI64arr8), d)
		case "AI64arr0":
			h.decArray0int64((*[0]int64)(&x.AI64arr0), d)
		case "AI64slice0":
			z.F.DecSliceInt64X(&x.AI64slice0, d)
		case "AUi64sliceN":
			z.F.DecSliceUint64X(&x.AUi64sliceN, d)
		default:
			z.DecStructFieldNotFound(-1, string(yys3))
		} // end switch yys3
	} // end for yyj3
}

func (x *AnonInTestStruc) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj20 int
	var yyb20 bool
	var yyhl20 bool = l >= 0
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.AS = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.AI64 = (int64)(r.DecodeInt64())
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.AI16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.AUi64 = (uint64)(r.DecodeUint64())
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceInt64X(&x.AI64slice, d)
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceUint64X(&x.AUi64slice, d)
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decArray8int64((*[8]int64)(&x.AI64arr8), d)
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decArray0int64((*[0]int64)(&x.AI64arr0), d)
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceInt64X(&x.AI64slice0, d)
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceUint64X(&x.AUi64sliceN, d)
	for {
		yyj20++
		if yyhl20 {
			yyb20 = yyj20 > l
		} else {
			yyb20 = z.DecCheckBreak()
		}
		if yyb20 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj20-1, "")
	}
}

func (x *AnonInTestStruc) IsCodecEmpty() bool {
	return !(x.AS != "" || x.AI64 != 0 || x.AI16 != 0 || x.AUi64 != 0 || len(x.AI64slice) != 0 || len(x.AUi64slice) != 0 || len(x.AI64arr8) != 0 || len(x.AI64arr0) != 0 || len(x.AI64slice0) != 0 || len(x.AUi64sliceN) != 0 || false)
}

func (TestSimpleFields) codecSelferViaCodecgen() {}
func (x *TestSimpleFields) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if z.EncBasicHandle().CheckCircularRef {
		z.EncEncode(x)
		return
	}
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(9)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.S))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I64))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I8))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.Ui64))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.Ui8))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.B))
			z.EncWriteArrayElem()
			if x.I32slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt32V(x.I32slice, e)
			} // end block: if x.I32slice slice == nil
			z.EncWriteArrayElem()
			if x.Ui64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.Ui64slice, e)
			} // end block: if x.Ui64slice slice == nil
			z.EncWriteArrayElem()
			if yyxt20 := z.Extension(x.WrapSliceInt64); yyxt20 != nil {
				z.EncExtension(x.WrapSliceInt64, yyxt20)
			} else {
				x.WrapSliceInt64.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(9)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"S\"")
			} else {
				r.EncodeString(`S`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.S))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I64\"")
			} else {
				r.EncodeString(`I64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I8\"")
			} else {
				r.EncodeString(`I8`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I8))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui64\"")
			} else {
				r.EncodeString(`Ui64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.Ui64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui8\"")
			} else {
				r.EncodeString(`Ui8`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.Ui8))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"B\"")
			} else {
				r.EncodeString(`B`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.B))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I32slice\"")
			} else {
				r.EncodeString(`I32slice`)
			}
			z.EncWriteMapElemValue()
			if x.I32slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt32V(x.I32slice, e)
			} // end block: if x.I32slice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui64slice\"")
			} else {
				r.EncodeString(`Ui64slice`)
			}
			z.EncWriteMapElemValue()
			if x.Ui64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.Ui64slice, e)
			} // end block: if x.Ui64slice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"WrapSliceInt64\"")
			} else {
				r.EncodeString(`WrapSliceInt64`)
			}
			z.EncWriteMapElemValue()
			if yyxt29 := z.Extension(x.WrapSliceInt64); yyxt29 != nil {
				z.EncExtension(x.WrapSliceInt64, yyxt29)
			} else {
				x.WrapSliceInt64.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *TestSimpleFields) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil5629 {
		*(x) = TestSimpleFields{}
	} else if yyct2 == codecSelferValueTypeMap5629 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray5629 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct5629)
	}
}

func (x *TestSimpleFields) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := r.DecodeStringAsBytes()
		z.DecReadMapElemValue()
		switch string(yys3) {
		case "S":
			x.S = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
		case "I64":
			x.I64 = (int64)(r.DecodeInt64())
		case "I8":
			x.I8 = (int8)(z.C.IntV(r.DecodeInt64(), 8))
		case "Ui64":
			x.Ui64 = (uint64)(r.DecodeUint64())
		case "Ui8":
			x.Ui8 = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
		case "B":
			x.B = (bool)(r.DecodeBool())
		case "I32slice":
			z.F.DecSliceInt32X(&x.I32slice, d)
		case "Ui64slice":
			z.F.DecSliceUint64X(&x.Ui64slice, d)
		case "WrapSliceInt64":
			if yyxt15 := z.Extension(x.WrapSliceInt64); yyxt15 != nil {
				z.DecExtension(&x.WrapSliceInt64, yyxt15)
			} else {
				x.WrapSliceInt64.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, string(yys3))
		} // end switch yys3
	} // end for yyj3
}

func (x *TestSimpleFields) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj16 int
	var yyb16 bool
	var yyhl16 bool = l >= 0
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.S = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.I64 = (int64)(r.DecodeInt64())
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.I8 = (int8)(z.C.IntV(r.DecodeInt64(), 8))
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Ui64 = (uint64)(r.DecodeUint64())
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Ui8 = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.B = (bool)(r.DecodeBool())
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceInt32X(&x.I32slice, d)
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceUint64X(&x.Ui64slice, d)
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt28 := z.Extension(x.WrapSliceInt64); yyxt28 != nil {
		z.DecExtension(&x.WrapSliceInt64, yyxt28)
	} else {
		x.WrapSliceInt64.CodecDecodeSelf(d)
	}
	for {
		yyj16++
		if yyhl16 {
			yyb16 = yyj16 > l
		} else {
			yyb16 = z.DecCheckBreak()
		}
		if yyb16 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj16-1, "")
	}
}

func (x *TestSimpleFields) IsCodecEmpty() bool {
	return !(x.S != "" || x.I64 != 0 || x.I8 != 0 || x.Ui64 != 0 || x.Ui8 != 0 || bool(x.B) || len(x.I32slice) != 0 || len(x.Ui64slice) != 0 || len(x.WrapSliceInt64) != 0 || false)
}

func (TestStrucCommon) codecSelferViaCodecgen() {}
func (x *TestStrucCommon) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if z.EncBasicHandle().CheckCircularRef {
		z.EncEncode(x)
		return
	}
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(36)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.S))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I64))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I32))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I16))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I8))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I64n))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I32n))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I16n))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.I8n))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.Ui64))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.Ui32))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.Ui16))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.Ui8))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.B))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.By))
			z.EncWriteArrayElem()
			if x.I64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.I64slice, e)
			} // end block: if x.I64slice slice == nil
			z.EncWriteArrayElem()
			if x.I32slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt32V(x.I32slice, e)
			} // end block: if x.I32slice slice == nil
			z.EncWriteArrayElem()
			if x.Ui64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.Ui64slice, e)
			} // end block: if x.Ui64slice slice == nil
			z.EncWriteArrayElem()
			if x.Byslice == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Byslice))
			} // end block: if x.Byslice slice == nil
			z.EncWriteArrayElem()
			if x.BytesSlice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceBytesV(x.BytesSlice, e)
			} // end block: if x.BytesSlice slice == nil
			z.EncWriteArrayElem()
			if yyxt59 := z.Extension(x.WrapSliceInt64); yyxt59 != nil {
				z.EncExtension(x.WrapSliceInt64, yyxt59)
			} else {
				x.WrapSliceInt64.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			yy60 := &x.Simplef
			if yyxt61 := z.Extension(yy60); yyxt61 != nil {
				z.EncExtension(yy60, yyxt61)
			} else {
				yy60.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if x.SstrUi64T == nil {
				r.EncodeNil()
			} else {
				h.encSliceStringUint64T(([]StringUint64T)(x.SstrUi64T), e)
			} // end block: if x.SstrUi64T slice == nil
			z.EncWriteArrayElem()
			if x.MstrUi64T == nil {
				r.EncodeNil()
			} else {
				h.encMapstringPtrtoStringUint64T((map[string]*StringUint64T)(x.MstrUi64T), e)
			} // end block: if x.MstrUi64T map == nil
			z.EncWriteArrayElem()
			r.EncodeString(string(x.AnonInTestStruc.AS))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.AnonInTestStruc.AI64))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.AnonInTestStruc.AI16))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.AnonInTestStruc.AUi64))
			z.EncWriteArrayElem()
			if x.AnonInTestStruc.AI64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.AnonInTestStruc.AI64slice, e)
			} // end block: if x.AnonInTestStruc.AI64slice slice == nil
			z.EncWriteArrayElem()
			if x.AnonInTestStruc.AUi64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.AnonInTestStruc.AUi64slice, e)
			} // end block: if x.AnonInTestStruc.AUi64slice slice == nil
			z.EncWriteArrayElem()
			yy70 := &x.AnonInTestStruc.AI64arr8
			h.encArray8int64((*[8]int64)(yy70), e)
			z.EncWriteArrayElem()
			yy72 := &x.AnonInTestStruc.AI64arr0
			h.encArray0int64((*[0]int64)(yy72), e)
			z.EncWriteArrayElem()
			if x.AnonInTestStruc.AI64slice0 == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.AnonInTestStruc.AI64slice0, e)
			} // end block: if x.AnonInTestStruc.AI64slice0 slice == nil
			z.EncWriteArrayElem()
			if x.AnonInTestStruc.AUi64sliceN == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.AnonInTestStruc.AUi64sliceN, e)
			} // end block: if x.AnonInTestStruc.AUi64sliceN slice == nil
			z.EncWriteArrayElem()
			yy76 := &x.NotAnon
			if yyxt77 := z.Extension(yy76); yyxt77 != nil {
				z.EncExtension(yy76, yyxt77)
			} else {
				yy76.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if x.Nslice == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Nslice))
			} // end block: if x.Nslice slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(36)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"S\"")
			} else {
				r.EncodeString(`S`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.S))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I64\"")
			} else {
				r.EncodeString(`I64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I32\"")
			} else {
				r.EncodeString(`I32`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I32))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I16\"")
			} else {
				r.EncodeString(`I16`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I16))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I8\"")
			} else {
				r.EncodeString(`I8`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I8))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I64n\"")
			} else {
				r.EncodeString(`I64n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I64n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I32n\"")
			} else {
				r.EncodeString(`I32n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I32n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I16n\"")
			} else {
				r.EncodeString(`I16n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I16n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I8n\"")
			} else {
				r.EncodeString(`I8n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.I8n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui64\"")
			} else {
				r.EncodeString(`Ui64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.Ui64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui32\"")
			} else {
				r.EncodeString(`Ui32`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.Ui32))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui16\"")
			} else {
				r.EncodeString(`Ui16`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.Ui16))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui8\"")
			} else {
				r.EncodeString(`Ui8`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.Ui8))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"B\"")
			} else {
				r.EncodeString(`B`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.B))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"By\"")
			} else {
				r.EncodeString(`By`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.By))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I64slice\"")
			} else {
				r.EncodeString(`I64slice`)
			}
			z.EncWriteMapElemValue()
			if x.I64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.I64slice, e)
			} // end block: if x.I64slice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I32slice\"")
			} else {
				r.EncodeString(`I32slice`)
			}
			z.EncWriteMapElemValue()
			if x.I32slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt32V(x.I32slice, e)
			} // end block: if x.I32slice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui64slice\"")
			} else {
				r.EncodeString(`Ui64slice`)
			}
			z.EncWriteMapElemValue()
			if x.Ui64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.Ui64slice, e)
			} // end block: if x.Ui64slice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Byslice\"")
			} else {
				r.EncodeString(`Byslice`)
			}
			z.EncWriteMapElemValue()
			if x.Byslice == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Byslice))
			} // end block: if x.Byslice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"BytesSlice\"")
			} else {
				r.EncodeString(`BytesSlice`)
			}
			z.EncWriteMapElemValue()
			if x.BytesSlice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceBytesV(x.BytesSlice, e)
			} // end block: if x.BytesSlice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"WrapSliceInt64\"")
			} else {
				r.EncodeString(`WrapSliceInt64`)
			}
			z.EncWriteMapElemValue()
			if yyxt99 := z.Extension(x.WrapSliceInt64); yyxt99 != nil {
				z.EncExtension(x.WrapSliceInt64, yyxt99)
			} else {
				x.WrapSliceInt64.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Simplef\"")
			} else {
				r.EncodeString(`Simplef`)
			}
			z.EncWriteMapElemValue()
			yy100 := &x.Simplef
			if yyxt101 := z.Extension(yy100); yyxt101 != nil {
				z.EncExtension(yy100, yyxt101)
			} else {
				yy100.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"SstrUi64T\"")
			} else {
				r.EncodeString(`SstrUi64T`)
			}
			z.EncWriteMapElemValue()
			if x.SstrUi64T == nil {
				r.EncodeNil()
			} else {
				h.encSliceStringUint64T(([]StringUint64T)(x.SstrUi64T), e)
			} // end block: if x.SstrUi64T slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"MstrUi64T\"")
			} else {
				r.EncodeString(`MstrUi64T`)
			}
			z.EncWriteMapElemValue()
			if x.MstrUi64T == nil {
				r.EncodeNil()
			} else {
				h.encMapstringPtrtoStringUint64T((map[string]*StringUint64T)(x.MstrUi64T), e)
			} // end block: if x.MstrUi64T map == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AS\"")
			} else {
				r.EncodeString(`AS`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.AnonInTestStruc.AS))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64\"")
			} else {
				r.EncodeString(`AI64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.AnonInTestStruc.AI64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI16\"")
			} else {
				r.EncodeString(`AI16`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.AnonInTestStruc.AI16))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64\"")
			} else {
				r.EncodeString(`AUi64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.AnonInTestStruc.AUi64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64slice\"")
			} else {
				r.EncodeString(`AI64slice`)
			}
			z.EncWriteMapElemValue()
			if x.AnonInTestStruc.AI64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.AnonInTestStruc.AI64slice, e)
			} // end block: if x.AnonInTestStruc.AI64slice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64slice\"")
			} else {
				r.EncodeString(`AUi64slice`)
			}
			z.EncWriteMapElemValue()
			if x.AnonInTestStruc.AUi64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.AnonInTestStruc.AUi64slice, e)
			} // end block: if x.AnonInTestStruc.AUi64slice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64arr8\"")
			} else {
				r.EncodeString(`AI64arr8`)
			}
			z.EncWriteMapElemValue()
			yy110 := &x.AnonInTestStruc.AI64arr8
			h.encArray8int64((*[8]int64)(yy110), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64arr0\"")
			} else {
				r.EncodeString(`AI64arr0`)
			}
			z.EncWriteMapElemValue()
			yy112 := &x.AnonInTestStruc.AI64arr0
			h.encArray0int64((*[0]int64)(yy112), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64slice0\"")
			} else {
				r.EncodeString(`AI64slice0`)
			}
			z.EncWriteMapElemValue()
			if x.AnonInTestStruc.AI64slice0 == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.AnonInTestStruc.AI64slice0, e)
			} // end block: if x.AnonInTestStruc.AI64slice0 slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64sliceN\"")
			} else {
				r.EncodeString(`AUi64sliceN`)
			}
			z.EncWriteMapElemValue()
			if x.AnonInTestStruc.AUi64sliceN == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.AnonInTestStruc.AUi64sliceN, e)
			} // end block: if x.AnonInTestStruc.AUi64sliceN slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"NotAnon\"")
			} else {
				r.EncodeString(`NotAnon`)
			}
			z.EncWriteMapElemValue()
			yy116 := &x.NotAnon
			if yyxt117 := z.Extension(yy116); yyxt117 != nil {
				z.EncExtension(yy116, yyxt117)
			} else {
				yy116.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Nslice\"")
			} else {
				r.EncodeString(`Nslice`)
			}
			z.EncWriteMapElemValue()
			if x.Nslice == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Nslice))
			} // end block: if x.Nslice slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *TestStrucCommon) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil5629 {
		*(x) = TestStrucCommon{}
	} else if yyct2 == codecSelferValueTypeMap5629 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray5629 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct5629)
	}
}

func (x *TestStrucCommon) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := r.DecodeStringAsBytes()
		z.DecReadMapElemValue()
		switch string(yys3) {
		case "S":
			x.S = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
		case "I64":
			x.I64 = (int64)(r.DecodeInt64())
		case "I32":
			x.I32 = (int32)(z.C.IntV(r.DecodeInt64(), 32))
		case "I16":
			x.I16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
		case "I8":
			x.I8 = (int8)(z.C.IntV(r.DecodeInt64(), 8))
		case "I64n":
			x.I64n = (int64)(r.DecodeInt64())
		case "I32n":
			x.I32n = (int32)(z.C.IntV(r.DecodeInt64(), 32))
		case "I16n":
			x.I16n = (int16)(z.C.IntV(r.DecodeInt64(), 16))
		case "I8n":
			x.I8n = (int8)(z.C.IntV(r.DecodeInt64(), 8))
		case "Ui64":
			x.Ui64 = (uint64)(r.DecodeUint64())
		case "Ui32":
			x.Ui32 = (uint32)(z.C.UintV(r.DecodeUint64(), 32))
		case "Ui16":
			x.Ui16 = (uint16)(z.C.UintV(r.DecodeUint64(), 16))
		case "Ui8":
			x.Ui8 = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
		case "B":
			x.B = (bool)(r.DecodeBool())
		case "By":
			x.By = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
		case "I64slice":
			z.F.DecSliceInt64X(&x.I64slice, d)
		case "I32slice":
			z.F.DecSliceInt32X(&x.I32slice, d)
		case "Ui64slice":
			z.F.DecSliceUint64X(&x.Ui64slice, d)
		case "Byslice":
			x.Byslice = z.DecodeBytesInto(([]byte)(x.Byslice))
		case "BytesSlice":
			z.F.DecSliceBytesX(&x.BytesSlice, d)
		case "WrapSliceInt64":
			if yyxt30 := z.Extension(x.WrapSliceInt64); yyxt30 != nil {
				z.DecExtension(&x.WrapSliceInt64, yyxt30)
			} else {
				x.WrapSliceInt64.CodecDecodeSelf(d)
			}
		case "Simplef":
			if yyxt32 := z.Extension(x.Simplef); yyxt32 != nil {
				z.DecExtension(&x.Simplef, yyxt32)
			} else {
				x.Simplef.CodecDecodeSelf(d)
			}
		case "SstrUi64T":
			h.decSliceStringUint64T((*[]StringUint64T)(&x.SstrUi64T), d)
		case "MstrUi64T":
			h.decMapstringPtrtoStringUint64T((*map[string]*StringUint64T)(&x.MstrUi64T), d)
		case "AS":
			x.AnonInTestStruc.AS = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
		case "AI64":
			x.AnonInTestStruc.AI64 = (int64)(r.DecodeInt64())
		case "AI16":
			x.AnonInTestStruc.AI16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
		case "AUi64":
			x.AnonInTestStruc.AUi64 = (uint64)(r.DecodeUint64())
		case "AI64slice":
			z.F.DecSliceInt64X(&x.AnonInTestStruc.AI64slice, d)
		case "AUi64slice":
			z.F.DecSliceUint64X(&x.AnonInTestStruc.AUi64slice, d)
		case "AI64arr8":
			h.decArray8int64((*[8]int64)(&x.AnonInTestStruc.AI64arr8), d)
		case "AI64arr0":
			h.decArray0int64((*[0]int64)(&x.AnonInTestStruc.AI64arr0), d)
		case "AI64slice0":
			z.F.DecSliceInt64X(&x.AnonInTestStruc.AI64slice0, d)
		case "AUi64sliceN":
			z.F.DecSliceUint64X(&x.AnonInTestStruc.AUi64sliceN, d)
		case "NotAnon":
			if yyxt54 := z.Extension(x.NotAnon); yyxt54 != nil {
				z.DecExtension(&x.NotAnon, yyxt54)
			} else {
				x.NotAnon.CodecDecodeSelf(d)
			}
		case "Nslice":
			x.Nslice = z.DecodeBytesInto(([]byte)(x.Nslice))
		default:
			z.DecStructFieldNotFound(-1, string(yys3))
		} // end switch yys3
	} // end for yyj3
}

func (x *TestStrucCommon) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj57 int
	var yyb57 bool
	var yyhl57 bool = l >= 0
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.S = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.I64 = (int64)(r.DecodeInt64())
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.I32 = (int32)(z.C.IntV(r.DecodeInt64(), 32))
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.I16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.I8 = (int8)(z.C.IntV(r.DecodeInt64(), 8))
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.I64n = (int64)(r.DecodeInt64())
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.I32n = (int32)(z.C.IntV(r.DecodeInt64(), 32))
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.I16n = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.I8n = (int8)(z.C.IntV(r.DecodeInt64(), 8))
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Ui64 = (uint64)(r.DecodeUint64())
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Ui32 = (uint32)(z.C.UintV(r.DecodeUint64(), 32))
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Ui16 = (uint16)(z.C.UintV(r.DecodeUint64(), 16))
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Ui8 = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.B = (bool)(r.DecodeBool())
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.By = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceInt64X(&x.I64slice, d)
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceInt32X(&x.I32slice, d)
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceUint64X(&x.Ui64slice, d)
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Byslice = z.DecodeBytesInto(([]byte)(x.Byslice))
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceBytesX(&x.BytesSlice, d)
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt84 := z.Extension(x.WrapSliceInt64); yyxt84 != nil {
		z.DecExtension(&x.WrapSliceInt64, yyxt84)
	} else {
		x.WrapSliceInt64.CodecDecodeSelf(d)
	}
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt86 := z.Extension(x.Simplef); yyxt86 != nil {
		z.DecExtension(&x.Simplef, yyxt86)
	} else {
		x.Simplef.CodecDecodeSelf(d)
	}
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSliceStringUint64T((*[]StringUint64T)(&x.SstrUi64T), d)
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decMapstringPtrtoStringUint64T((*map[string]*StringUint64T)(&x.MstrUi64T), d)
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.AnonInTestStruc.AS = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.AnonInTestStruc.AI64 = (int64)(r.DecodeInt64())
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.AnonInTestStruc.AI16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.AnonInTestStruc.AUi64 = (uint64)(r.DecodeUint64())
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceInt64X(&x.AnonInTestStruc.AI64slice, d)
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceUint64X(&x.AnonInTestStruc.AUi64slice, d)
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decArray8int64((*[8]int64)(&x.AnonInTestStruc.AI64arr8), d)
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decArray0int64((*[0]int64)(&x.AnonInTestStruc.AI64arr0), d)
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceInt64X(&x.AnonInTestStruc.AI64slice0, d)
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceUint64X(&x.AnonInTestStruc.AUi64sliceN, d)
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt108 := z.Extension(x.NotAnon); yyxt108 != nil {
		z.DecExtension(&x.NotAnon, yyxt108)
	} else {
		x.NotAnon.CodecDecodeSelf(d)
	}
	yyj57++
	if yyhl57 {
		yyb57 = yyj57 > l
	} else {
		yyb57 = z.DecCheckBreak()
	}
	if yyb57 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Nslice = z.DecodeBytesInto(([]byte)(x.Nslice))
	for {
		yyj57++
		if yyhl57 {
			yyb57 = yyj57 > l
		} else {
			yyb57 = z.DecCheckBreak()
		}
		if yyb57 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj57-1, "")
	}
}

func (x *TestStrucCommon) IsCodecEmpty() bool {
	return !(x.S != "" || x.I64 != 0 || x.I32 != 0 || x.I16 != 0 || x.I8 != 0 || x.I64n != 0 || x.I32n != 0 || x.I16n != 0 || x.I8n != 0 || x.Ui64 != 0 || x.Ui32 != 0 || x.Ui16 != 0 || x.Ui8 != 0 || bool(x.B) || x.By != 0 || len(x.I64slice) != 0 || len(x.I32slice) != 0 || len(x.Ui64slice) != 0 || len(x.Byslice) != 0 || len(x.BytesSlice) != 0 || len(x.WrapSliceInt64) != 0 || !(x.Simplef.IsCodecEmpty()) || len(x.SstrUi64T) != 0 || len(x.MstrUi64T) != 0 || !(x.AnonInTestStruc.IsCodecEmpty()) || !(x.NotAnon.IsCodecEmpty()) || len(x.Nslice) != 0 || false)
}

func (TestStruc) codecSelferViaCodecgen() {}
func (x *TestStruc) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if z.EncBasicHandle().CheckCircularRef {
		z.EncEncode(x)
		return
	}
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn42 bool = x.Nteststruc == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(40)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.TestStrucCommon.S))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I64))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I32))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I16))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I8))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I64n))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I32n))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I16n))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.I8n))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui64))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui32))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui16))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui8))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.TestStrucCommon.B))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.TestStrucCommon.By))
			z.EncWriteArrayElem()
			if x.TestStrucCommon.I64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.TestStrucCommon.I64slice, e)
			} // end block: if x.TestStrucCommon.I64slice slice == nil
			z.EncWriteArrayElem()
			if x.TestStrucCommon.I32slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt32V(x.TestStrucCommon.I32slice, e)
			} // end block: if x.TestStrucCommon.I32slice slice == nil
			z.EncWriteArrayElem()
			if x.TestStrucCommon.Ui64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.TestStrucCommon.Ui64slice, e)
			} // end block: if x.TestStrucCommon.Ui64slice slice == nil
			z.EncWriteArrayElem()
			if x.TestStrucCommon.Byslice == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Byslice))
			} // end block: if x.TestStrucCommon.Byslice slice == nil
			z.EncWriteArrayElem()
			if x.TestStrucCommon.BytesSlice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceBytesV(x.TestStrucCommon.BytesSlice, e)
			} // end block: if x.TestStrucCommon.BytesSlice slice == nil
			z.EncWriteArrayElem()
			if yyxt63 := z.Extension(x.TestStrucCommon.WrapSliceInt64); yyxt63 != nil {
				z.EncExtension(x.TestStrucCommon.WrapSliceInt64, yyxt63)
			} else {
				x.TestStrucCommon.WrapSliceInt64.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			yy64 := &x.TestStrucCommon.Simplef
			if yyxt65 := z.Extension(yy64); yyxt65 != nil {
				z.EncExtension(yy64, yyxt65)
			} else {
				yy64.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if x.TestStrucCommon.SstrUi64T == nil {
				r.EncodeNil()
			} else {
				h.encSliceStringUint64T(([]StringUint64T)(x.TestStrucCommon.SstrUi64T), e)
			} // end block: if x.TestStrucCommon.SstrUi64T slice == nil
			z.EncWriteArrayElem()
			if x.TestStrucCommon.MstrUi64T == nil {
				r.EncodeNil()
			} else {
				h.encMapstringPtrtoStringUint64T((map[string]*StringUint64T)(x.TestStrucCommon.MstrUi64T), e)
			} // end block: if x.TestStrucCommon.MstrUi64T map == nil
			z.EncWriteArrayElem()
			r.EncodeString(string(x.TestStrucCommon.AnonInTestStruc.AS))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.AnonInTestStruc.AI64))
			z.EncWriteArrayElem()
			r.EncodeInt(int64(x.TestStrucCommon.AnonInTestStruc.AI16))
			z.EncWriteArrayElem()
			r.EncodeUint(uint64(x.TestStrucCommon.AnonInTestStruc.AUi64))
			z.EncWriteArrayElem()
			if x.TestStrucCommon.AnonInTestStruc.AI64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.TestStrucCommon.AnonInTestStruc.AI64slice, e)
			} // end block: if x.TestStrucCommon.AnonInTestStruc.AI64slice slice == nil
			z.EncWriteArrayElem()
			if x.TestStrucCommon.AnonInTestStruc.AUi64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.TestStrucCommon.AnonInTestStruc.AUi64slice, e)
			} // end block: if x.TestStrucCommon.AnonInTestStruc.AUi64slice slice == nil
			z.EncWriteArrayElem()
			yy74 := &x.TestStrucCommon.AnonInTestStruc.AI64arr8
			h.encArray8int64((*[8]int64)(yy74), e)
			z.EncWriteArrayElem()
			yy76 := &x.TestStrucCommon.AnonInTestStruc.AI64arr0
			h.encArray0int64((*[0]int64)(yy76), e)
			z.EncWriteArrayElem()
			if x.TestStrucCommon.AnonInTestStruc.AI64slice0 == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.TestStrucCommon.AnonInTestStruc.AI64slice0, e)
			} // end block: if x.TestStrucCommon.AnonInTestStruc.AI64slice0 slice == nil
			z.EncWriteArrayElem()
			if x.TestStrucCommon.AnonInTestStruc.AUi64sliceN == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.TestStrucCommon.AnonInTestStruc.AUi64sliceN, e)
			} // end block: if x.TestStrucCommon.AnonInTestStruc.AUi64sliceN slice == nil
			z.EncWriteArrayElem()
			yy80 := &x.TestStrucCommon.NotAnon
			if yyxt81 := z.Extension(yy80); yyxt81 != nil {
				z.EncExtension(yy80, yyxt81)
			} else {
				yy80.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if x.TestStrucCommon.Nslice == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Nslice))
			} // end block: if x.TestStrucCommon.Nslice slice == nil
			z.EncWriteArrayElem()
			if x.Mtsptr == nil {
				r.EncodeNil()
			} else {
				h.encMapstringPtrtoTestStruc((map[string]*TestStruc)(x.Mtsptr), e)
			} // end block: if x.Mtsptr map == nil
			z.EncWriteArrayElem()
			if x.Mts == nil {
				r.EncodeNil()
			} else {
				h.encMapstringTestStruc((map[string]TestStruc)(x.Mts), e)
			} // end block: if x.Mts map == nil
			z.EncWriteArrayElem()
			if x.Its == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoTestStruc(([]*TestStruc)(x.Its), e)
			} // end block: if x.Its slice == nil
			if yyn42 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt86 := z.Extension(x.Nteststruc); yyxt86 != nil {
					z.EncExtension(x.Nteststruc, yyxt86)
				} else {
					x.Nteststruc.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(40)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"S\"")
			} else {
				r.EncodeString(`S`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.TestStrucCommon.S))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I64\"")
			} else {
				r.EncodeString(`I64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I32\"")
			} else {
				r.EncodeString(`I32`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I32))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I16\"")
			} else {
				r.EncodeString(`I16`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I16))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I8\"")
			} else {
				r.EncodeString(`I8`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I8))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I64n\"")
			} else {
				r.EncodeString(`I64n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I64n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I32n\"")
			} else {
				r.EncodeString(`I32n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I32n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I16n\"")
			} else {
				r.EncodeString(`I16n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I16n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I8n\"")
			} else {
				r.EncodeString(`I8n`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.I8n))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui64\"")
			} else {
				r.EncodeString(`Ui64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui32\"")
			} else {
				r.EncodeString(`Ui32`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui32))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui16\"")
			} else {
				r.EncodeString(`Ui16`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui16))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui8\"")
			} else {
				r.EncodeString(`Ui8`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.TestStrucCommon.Ui8))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"B\"")
			} else {
				r.EncodeString(`B`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.TestStrucCommon.B))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"By\"")
			} else {
				r.EncodeString(`By`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.TestStrucCommon.By))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I64slice\"")
			} else {
				r.EncodeString(`I64slice`)
			}
			z.EncWriteMapElemValue()
			if x.TestStrucCommon.I64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.TestStrucCommon.I64slice, e)
			} // end block: if x.TestStrucCommon.I64slice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"I32slice\"")
			} else {
				r.EncodeString(`I32slice`)
			}
			z.EncWriteMapElemValue()
			if x.TestStrucCommon.I32slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt32V(x.TestStrucCommon.I32slice, e)
			} // end block: if x.TestStrucCommon.I32slice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Ui64slice\"")
			} else {
				r.EncodeString(`Ui64slice`)
			}
			z.EncWriteMapElemValue()
			if x.TestStrucCommon.Ui64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.TestStrucCommon.Ui64slice, e)
			} // end block: if x.TestStrucCommon.Ui64slice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Byslice\"")
			} else {
				r.EncodeString(`Byslice`)
			}
			z.EncWriteMapElemValue()
			if x.TestStrucCommon.Byslice == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Byslice))
			} // end block: if x.TestStrucCommon.Byslice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"BytesSlice\"")
			} else {
				r.EncodeString(`BytesSlice`)
			}
			z.EncWriteMapElemValue()
			if x.TestStrucCommon.BytesSlice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceBytesV(x.TestStrucCommon.BytesSlice, e)
			} // end block: if x.TestStrucCommon.BytesSlice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"WrapSliceInt64\"")
			} else {
				r.EncodeString(`WrapSliceInt64`)
			}
			z.EncWriteMapElemValue()
			if yyxt107 := z.Extension(x.TestStrucCommon.WrapSliceInt64); yyxt107 != nil {
				z.EncExtension(x.TestStrucCommon.WrapSliceInt64, yyxt107)
			} else {
				x.TestStrucCommon.WrapSliceInt64.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Simplef\"")
			} else {
				r.EncodeString(`Simplef`)
			}
			z.EncWriteMapElemValue()
			yy108 := &x.TestStrucCommon.Simplef
			if yyxt109 := z.Extension(yy108); yyxt109 != nil {
				z.EncExtension(yy108, yyxt109)
			} else {
				yy108.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"SstrUi64T\"")
			} else {
				r.EncodeString(`SstrUi64T`)
			}
			z.EncWriteMapElemValue()
			if x.TestStrucCommon.SstrUi64T == nil {
				r.EncodeNil()
			} else {
				h.encSliceStringUint64T(([]StringUint64T)(x.TestStrucCommon.SstrUi64T), e)
			} // end block: if x.TestStrucCommon.SstrUi64T slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"MstrUi64T\"")
			} else {
				r.EncodeString(`MstrUi64T`)
			}
			z.EncWriteMapElemValue()
			if x.TestStrucCommon.MstrUi64T == nil {
				r.EncodeNil()
			} else {
				h.encMapstringPtrtoStringUint64T((map[string]*StringUint64T)(x.TestStrucCommon.MstrUi64T), e)
			} // end block: if x.TestStrucCommon.MstrUi64T map == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AS\"")
			} else {
				r.EncodeString(`AS`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.TestStrucCommon.AnonInTestStruc.AS))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64\"")
			} else {
				r.EncodeString(`AI64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.AnonInTestStruc.AI64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI16\"")
			} else {
				r.EncodeString(`AI16`)
			}
			z.EncWriteMapElemValue()
			r.EncodeInt(int64(x.TestStrucCommon.AnonInTestStruc.AI16))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64\"")
			} else {
				r.EncodeString(`AUi64`)
			}
			z.EncWriteMapElemValue()
			r.EncodeUint(uint64(x.TestStrucCommon.AnonInTestStruc.AUi64))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64slice\"")
			} else {
				r.EncodeString(`AI64slice`)
			}
			z.EncWriteMapElemValue()
			if x.TestStrucCommon.AnonInTestStruc.AI64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.TestStrucCommon.AnonInTestStruc.AI64slice, e)
			} // end block: if x.TestStrucCommon.AnonInTestStruc.AI64slice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64slice\"")
			} else {
				r.EncodeString(`AUi64slice`)
			}
			z.EncWriteMapElemValue()
			if x.TestStrucCommon.AnonInTestStruc.AUi64slice == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.TestStrucCommon.AnonInTestStruc.AUi64slice, e)
			} // end block: if x.TestStrucCommon.AnonInTestStruc.AUi64slice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64arr8\"")
			} else {
				r.EncodeString(`AI64arr8`)
			}
			z.EncWriteMapElemValue()
			yy118 := &x.TestStrucCommon.AnonInTestStruc.AI64arr8
			h.encArray8int64((*[8]int64)(yy118), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64arr0\"")
			} else {
				r.EncodeString(`AI64arr0`)
			}
			z.EncWriteMapElemValue()
			yy120 := &x.TestStrucCommon.AnonInTestStruc.AI64arr0
			h.encArray0int64((*[0]int64)(yy120), e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AI64slice0\"")
			} else {
				r.EncodeString(`AI64slice0`)
			}
			z.EncWriteMapElemValue()
			if x.TestStrucCommon.AnonInTestStruc.AI64slice0 == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceInt64V(x.TestStrucCommon.AnonInTestStruc.AI64slice0, e)
			} // end block: if x.TestStrucCommon.AnonInTestStruc.AI64slice0 slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"AUi64sliceN\"")
			} else {
				r.EncodeString(`AUi64sliceN`)
			}
			z.EncWriteMapElemValue()
			if x.TestStrucCommon.AnonInTestStruc.AUi64sliceN == nil {
				r.EncodeNil()
			} else {
				z.F.EncSliceUint64V(x.TestStrucCommon.AnonInTestStruc.AUi64sliceN, e)
			} // end block: if x.TestStrucCommon.AnonInTestStruc.AUi64sliceN slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"NotAnon\"")
			} else {
				r.EncodeString(`NotAnon`)
			}
			z.EncWriteMapElemValue()
			yy124 := &x.TestStrucCommon.NotAnon
			if yyxt125 := z.Extension(yy124); yyxt125 != nil {
				z.EncExtension(yy124, yyxt125)
			} else {
				yy124.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Nslice\"")
			} else {
				r.EncodeString(`Nslice`)
			}
			z.EncWriteMapElemValue()
			if x.TestStrucCommon.Nslice == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.TestStrucCommon.Nslice))
			} // end block: if x.TestStrucCommon.Nslice slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Mtsptr\"")
			} else {
				r.EncodeString(`Mtsptr`)
			}
			z.EncWriteMapElemValue()
			if x.Mtsptr == nil {
				r.EncodeNil()
			} else {
				h.encMapstringPtrtoTestStruc((map[string]*TestStruc)(x.Mtsptr), e)
			} // end block: if x.Mtsptr map == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Mts\"")
			} else {
				r.EncodeString(`Mts`)
			}
			z.EncWriteMapElemValue()
			if x.Mts == nil {
				r.EncodeNil()
			} else {
				h.encMapstringTestStruc((map[string]TestStruc)(x.Mts), e)
			} // end block: if x.Mts map == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Its\"")
			} else {
				r.EncodeString(`Its`)
			}
			z.EncWriteMapElemValue()
			if x.Its == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoTestStruc(([]*TestStruc)(x.Its), e)
			} // end block: if x.Its slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Nteststruc\"")
			} else {
				r.EncodeString(`Nteststruc`)
			}
			z.EncWriteMapElemValue()
			if yyn42 {
				r.EncodeNil()
			} else {
				if yyxt130 := z.Extension(x.Nteststruc); yyxt130 != nil {
					z.EncExtension(x.Nteststruc, yyxt130)
				} else {
					x.Nteststruc.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *TestStruc) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil5629 {
		*(x) = TestStruc{}
	} else if yyct2 == codecSelferValueTypeMap5629 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray5629 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct5629)
	}
}

func (x *TestStruc) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := r.DecodeStringAsBytes()
		z.DecReadMapElemValue()
		switch string(yys3) {
		case "S":
			x.TestStrucCommon.S = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
		case "I64":
			x.TestStrucCommon.I64 = (int64)(r.DecodeInt64())
		case "I32":
			x.TestStrucCommon.I32 = (int32)(z.C.IntV(r.DecodeInt64(), 32))
		case "I16":
			x.TestStrucCommon.I16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
		case "I8":
			x.TestStrucCommon.I8 = (int8)(z.C.IntV(r.DecodeInt64(), 8))
		case "I64n":
			x.TestStrucCommon.I64n = (int64)(r.DecodeInt64())
		case "I32n":
			x.TestStrucCommon.I32n = (int32)(z.C.IntV(r.DecodeInt64(), 32))
		case "I16n":
			x.TestStrucCommon.I16n = (int16)(z.C.IntV(r.DecodeInt64(), 16))
		case "I8n":
			x.TestStrucCommon.I8n = (int8)(z.C.IntV(r.DecodeInt64(), 8))
		case "Ui64":
			x.TestStrucCommon.Ui64 = (uint64)(r.DecodeUint64())
		case "Ui32":
			x.TestStrucCommon.Ui32 = (uint32)(z.C.UintV(r.DecodeUint64(), 32))
		case "Ui16":
			x.TestStrucCommon.Ui16 = (uint16)(z.C.UintV(r.DecodeUint64(), 16))
		case "Ui8":
			x.TestStrucCommon.Ui8 = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
		case "B":
			x.TestStrucCommon.B = (bool)(r.DecodeBool())
		case "By":
			x.TestStrucCommon.By = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
		case "I64slice":
			z.F.DecSliceInt64X(&x.TestStrucCommon.I64slice, d)
		case "I32slice":
			z.F.DecSliceInt32X(&x.TestStrucCommon.I32slice, d)
		case "Ui64slice":
			z.F.DecSliceUint64X(&x.TestStrucCommon.Ui64slice, d)
		case "Byslice":
			x.TestStrucCommon.Byslice = z.DecodeBytesInto(([]byte)(x.TestStrucCommon.Byslice))
		case "BytesSlice":
			z.F.DecSliceBytesX(&x.TestStrucCommon.BytesSlice, d)
		case "WrapSliceInt64":
			if yyxt30 := z.Extension(x.TestStrucCommon.WrapSliceInt64); yyxt30 != nil {
				z.DecExtension(&x.TestStrucCommon.WrapSliceInt64, yyxt30)
			} else {
				x.TestStrucCommon.WrapSliceInt64.CodecDecodeSelf(d)
			}
		case "Simplef":
			if yyxt32 := z.Extension(x.TestStrucCommon.Simplef); yyxt32 != nil {
				z.DecExtension(&x.TestStrucCommon.Simplef, yyxt32)
			} else {
				x.TestStrucCommon.Simplef.CodecDecodeSelf(d)
			}
		case "SstrUi64T":
			h.decSliceStringUint64T((*[]StringUint64T)(&x.TestStrucCommon.SstrUi64T), d)
		case "MstrUi64T":
			h.decMapstringPtrtoStringUint64T((*map[string]*StringUint64T)(&x.TestStrucCommon.MstrUi64T), d)
		case "AS":
			x.TestStrucCommon.AnonInTestStruc.AS = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
		case "AI64":
			x.TestStrucCommon.AnonInTestStruc.AI64 = (int64)(r.DecodeInt64())
		case "AI16":
			x.TestStrucCommon.AnonInTestStruc.AI16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
		case "AUi64":
			x.TestStrucCommon.AnonInTestStruc.AUi64 = (uint64)(r.DecodeUint64())
		case "AI64slice":
			z.F.DecSliceInt64X(&x.TestStrucCommon.AnonInTestStruc.AI64slice, d)
		case "AUi64slice":
			z.F.DecSliceUint64X(&x.TestStrucCommon.AnonInTestStruc.AUi64slice, d)
		case "AI64arr8":
			h.decArray8int64((*[8]int64)(&x.TestStrucCommon.AnonInTestStruc.AI64arr8), d)
		case "AI64arr0":
			h.decArray0int64((*[0]int64)(&x.TestStrucCommon.AnonInTestStruc.AI64arr0), d)
		case "AI64slice0":
			z.F.DecSliceInt64X(&x.TestStrucCommon.AnonInTestStruc.AI64slice0, d)
		case "AUi64sliceN":
			z.F.DecSliceUint64X(&x.TestStrucCommon.AnonInTestStruc.AUi64sliceN, d)
		case "NotAnon":
			if yyxt54 := z.Extension(x.TestStrucCommon.NotAnon); yyxt54 != nil {
				z.DecExtension(&x.TestStrucCommon.NotAnon, yyxt54)
			} else {
				x.TestStrucCommon.NotAnon.CodecDecodeSelf(d)
			}
		case "Nslice":
			x.TestStrucCommon.Nslice = z.DecodeBytesInto(([]byte)(x.TestStrucCommon.Nslice))
		case "Mtsptr":
			h.decMapstringPtrtoTestStruc((*map[string]*TestStruc)(&x.Mtsptr), d)
		case "Mts":
			h.decMapstringTestStruc((*map[string]TestStruc)(&x.Mts), d)
		case "Its":
			h.decSlicePtrtoTestStruc((*[]*TestStruc)(&x.Its), d)
		case "Nteststruc":
			if r.TryNil() {
				if x.Nteststruc != nil { // remove the if-true
					x.Nteststruc = nil
				}
			} else {
				if x.Nteststruc == nil {
					x.Nteststruc = new(TestStruc)
				}
				if yyxt64 := z.Extension(x.Nteststruc); yyxt64 != nil {
					z.DecExtension(x.Nteststruc, yyxt64)
				} else {
					x.Nteststruc.CodecDecodeSelf(d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, string(yys3))
		} // end switch yys3
	} // end for yyj3
}

func (x *TestStruc) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj65 int
	var yyb65 bool
	var yyhl65 bool = l >= 0
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.S = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.I64 = (int64)(r.DecodeInt64())
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.I32 = (int32)(z.C.IntV(r.DecodeInt64(), 32))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.I16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.I8 = (int8)(z.C.IntV(r.DecodeInt64(), 8))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.I64n = (int64)(r.DecodeInt64())
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.I32n = (int32)(z.C.IntV(r.DecodeInt64(), 32))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.I16n = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.I8n = (int8)(z.C.IntV(r.DecodeInt64(), 8))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.Ui64 = (uint64)(r.DecodeUint64())
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.Ui32 = (uint32)(z.C.UintV(r.DecodeUint64(), 32))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.Ui16 = (uint16)(z.C.UintV(r.DecodeUint64(), 16))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.Ui8 = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.B = (bool)(r.DecodeBool())
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.By = (uint8)(z.C.UintV(r.DecodeUint64(), 8))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceInt64X(&x.TestStrucCommon.I64slice, d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceInt32X(&x.TestStrucCommon.I32slice, d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceUint64X(&x.TestStrucCommon.Ui64slice, d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.Byslice = z.DecodeBytesInto(([]byte)(x.TestStrucCommon.Byslice))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceBytesX(&x.TestStrucCommon.BytesSlice, d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt92 := z.Extension(x.TestStrucCommon.WrapSliceInt64); yyxt92 != nil {
		z.DecExtension(&x.TestStrucCommon.WrapSliceInt64, yyxt92)
	} else {
		x.TestStrucCommon.WrapSliceInt64.CodecDecodeSelf(d)
	}
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt94 := z.Extension(x.TestStrucCommon.Simplef); yyxt94 != nil {
		z.DecExtension(&x.TestStrucCommon.Simplef, yyxt94)
	} else {
		x.TestStrucCommon.Simplef.CodecDecodeSelf(d)
	}
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSliceStringUint64T((*[]StringUint64T)(&x.TestStrucCommon.SstrUi64T), d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decMapstringPtrtoStringUint64T((*map[string]*StringUint64T)(&x.TestStrucCommon.MstrUi64T), d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.AnonInTestStruc.AS = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.AnonInTestStruc.AI64 = (int64)(r.DecodeInt64())
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.AnonInTestStruc.AI16 = (int16)(z.C.IntV(r.DecodeInt64(), 16))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.AnonInTestStruc.AUi64 = (uint64)(r.DecodeUint64())
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceInt64X(&x.TestStrucCommon.AnonInTestStruc.AI64slice, d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceUint64X(&x.TestStrucCommon.AnonInTestStruc.AUi64slice, d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decArray8int64((*[8]int64)(&x.TestStrucCommon.AnonInTestStruc.AI64arr8), d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decArray0int64((*[0]int64)(&x.TestStrucCommon.AnonInTestStruc.AI64arr0), d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceInt64X(&x.TestStrucCommon.AnonInTestStruc.AI64slice0, d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.F.DecSliceUint64X(&x.TestStrucCommon.AnonInTestStruc.AUi64sliceN, d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt116 := z.Extension(x.TestStrucCommon.NotAnon); yyxt116 != nil {
		z.DecExtension(&x.TestStrucCommon.NotAnon, yyxt116)
	} else {
		x.TestStrucCommon.NotAnon.CodecDecodeSelf(d)
	}
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TestStrucCommon.Nslice = z.DecodeBytesInto(([]byte)(x.TestStrucCommon.Nslice))
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decMapstringPtrtoTestStruc((*map[string]*TestStruc)(&x.Mtsptr), d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decMapstringTestStruc((*map[string]TestStruc)(&x.Mts), d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSlicePtrtoTestStruc((*[]*TestStruc)(&x.Its), d)
	yyj65++
	if yyhl65 {
		yyb65 = yyj65 > l
	} else {
		yyb65 = z.DecCheckBreak()
	}
	if yyb65 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Nteststruc != nil { // remove the if-true
			x.Nteststruc = nil
		}
	} else {
		if x.Nteststruc == nil {
			x.Nteststruc = new(TestStruc)
		}
		if yyxt126 := z.Extension(x.Nteststruc); yyxt126 != nil {
			z.DecExtension(x.Nteststruc, yyxt126)
		} else {
			x.Nteststruc.CodecDecodeSelf(d)
		}
	}
	for {
		yyj65++
		if yyhl65 {
			yyb65 = yyj65 > l
		} else {
			yyb65 = z.DecCheckBreak()
		}
		if yyb65 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj65-1, "")
	}
}

func (x *TestStruc) IsCodecEmpty() bool {
	return !(!(x.TestStrucCommon.IsCodecEmpty()) || len(x.Mtsptr) != 0 || len(x.Mts) != 0 || len(x.Its) != 0 || false)
}

func (x codecSelfer5629) encwrapUint64Slice(v wrapUint64Slice, e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for yyv1 := range v {
		z.EncWriteArrayElem()
		if yyxt2 := z.Extension(v[yyv1]); yyxt2 != nil {
			z.EncExtension(v[yyv1], yyxt2)
		} else {
			v[yyv1].CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer5629) decwrapUint64Slice(v *wrapUint64Slice, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []wrapUint64{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]wrapUint64, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]wrapUint64, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, 0)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
					z.DecExtension(&yyv1[yyj1], yyxt3)
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]wrapUint64, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer5629) encArray8int64(v *[8]int64, e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for yyv1 := range v {
		z.EncWriteArrayElem()
		r.EncodeInt(int64(v[yyv1]))
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer5629) decArray8int64(v *[8]int64, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := v
	yyh1, yyl1 := z.DecSliceHelperStart()
	if yyl1 == 0 {
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				z.DecArrayCannotExpand(len(v), yyj1+1)
				yydb1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				yyv1[yyj1] = (int64)(r.DecodeInt64())
			}
		}
	}
	yyh1.End()
}

func (x codecSelfer5629) encArray0int64(v *[0]int64, e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for yyv1 := range v {
		z.EncWriteArrayElem()
		r.EncodeInt(int64(v[yyv1]))
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer5629) decArray0int64(v *[0]int64, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := v
	yyh1, yyl1 := z.DecSliceHelperStart()
	if yyl1 == 0 {
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				z.DecArrayCannotExpand(len(v), yyj1+1)
				yydb1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				yyv1[yyj1] = (int64)(r.DecodeInt64())
			}
		}
	}
	yyh1.End()
}

func (x codecSelfer5629) encSliceStringUint64T(v []StringUint64T, e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for yyv1 := range v {
		z.EncWriteArrayElem()
		yy2 := &v[yyv1]
		if yyxt3 := z.Extension(yy2); yyxt3 != nil {
			z.EncExtension(yy2, yyxt3)
		} else {
			yy2.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer5629) decSliceStringUint64T(v *[]StringUint64T, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []StringUint64T{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 24)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]StringUint64T, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 24)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]StringUint64T, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, StringUint64T{})
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
					z.DecExtension(&yyv1[yyj1], yyxt3)
				} else {
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]StringUint64T, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer5629) encMapstringPtrtoStringUint64T(v map[string]*StringUint64T, e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
	} else if z.EncBasicHandle().Canonical {
		z.EncEncodeMapNonNil(v)
	} else {
		z.EncWriteMapStart(len(v))
		for yyk1, yyv1 := range v {
			z.EncWriteMapElemKey()
			r.EncodeString(string(yyk1))
			z.EncWriteMapElemValue()
			if yyv1 == nil {
				r.EncodeNil()
			} else {
				if yyxt3 := z.Extension(yyv1); yyxt3 != nil {
					z.EncExtension(yyv1, yyxt3)
				} else {
					yyv1.CodecEncodeSelf(e)
				}
			}
		}
		z.EncWriteMapEnd()
	}
}

func (x codecSelfer5629) decMapstringPtrtoStringUint64T(v *map[string]*StringUint64T, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	if yyl1 == codecSelferDecContainerLenNil5629 {
		*v = nil
	} else {
		if yyv1 == nil {
			yyrl1 := z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 24)
			yyv1 = make(map[string]*StringUint64T, yyrl1)
			*v = yyv1
		}
		var yymk1 string
		var yymv1 *StringUint64T
		var yymg1, yymdn1, yyms1, yymok1 bool
		if z.DecBasicHandle().MapValueReset {
			yymg1 = true
		}
		if yyl1 != 0 {
			yyhl1 := yyl1 > 0
			for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ {
				z.DecReadMapElemKey()
				yymk1 = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
				yyms1 = true
				if yymg1 {
					yymv1, yymok1 = yyv1[yymk1]
					if yymok1 {
						yyms1 = false
					}
				} else {
					yymv1 = nil
				}
				z.DecReadMapElemValue()
				yymdn1 = false
				if r.TryNil() {
					yymdn1 = true
				} else {
					if yymv1 == nil {
						yymv1 = new(StringUint64T)
					}
					if yyxt4 := z.Extension(yymv1); yyxt4 != nil {
						z.DecExtension(yymv1, yyxt4)
					} else {
						yymv1.CodecDecodeSelf(d)
					}
				}
				if yymdn1 {
					yyv1[yymk1] = nil
				} else if yyms1 {
					yyv1[yymk1] = yymv1
				}
			}
		} // else len==0: leave as-is (do not clear map entries)
		z.DecReadMapEnd()
	}
}

func (x codecSelfer5629) encMapstringPtrtoTestStruc(v map[string]*TestStruc, e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
	} else if z.EncBasicHandle().Canonical {
		z.EncEncodeMapNonNil(v)
	} else {
		z.EncWriteMapStart(len(v))
		for yyk1, yyv1 := range v {
			z.EncWriteMapElemKey()
			r.EncodeString(string(yyk1))
			z.EncWriteMapElemValue()
			if yyv1 == nil {
				r.EncodeNil()
			} else {
				if yyxt3 := z.Extension(yyv1); yyxt3 != nil {
					z.EncExtension(yyv1, yyxt3)
				} else {
					yyv1.CodecEncodeSelf(e)
				}
			}
		}
		z.EncWriteMapEnd()
	}
}

func (x codecSelfer5629) decMapstringPtrtoTestStruc(v *map[string]*TestStruc, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	if yyl1 == codecSelferDecContainerLenNil5629 {
		*v = nil
	} else {
		if yyv1 == nil {
			yyrl1 := z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 24)
			yyv1 = make(map[string]*TestStruc, yyrl1)
			*v = yyv1
		}
		var yymk1 string
		var yymv1 *TestStruc
		var yymg1, yymdn1, yyms1, yymok1 bool
		if z.DecBasicHandle().MapValueReset {
			yymg1 = true
		}
		if yyl1 != 0 {
			yyhl1 := yyl1 > 0
			for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ {
				z.DecReadMapElemKey()
				yymk1 = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
				yyms1 = true
				if yymg1 {
					yymv1, yymok1 = yyv1[yymk1]
					if yymok1 {
						yyms1 = false
					}
				} else {
					yymv1 = nil
				}
				z.DecReadMapElemValue()
				yymdn1 = false
				if r.TryNil() {
					yymdn1 = true
				} else {
					if yymv1 == nil {
						yymv1 = new(TestStruc)
					}
					if yyxt4 := z.Extension(yymv1); yyxt4 != nil {
						z.DecExtension(yymv1, yyxt4)
					} else {
						yymv1.CodecDecodeSelf(d)
					}
				}
				if yymdn1 {
					yyv1[yymk1] = nil
				} else if yyms1 {
					yyv1[yymk1] = yymv1
				}
			}
		} // else len==0: leave as-is (do not clear map entries)
		z.DecReadMapEnd()
	}
}

func (x codecSelfer5629) encMapstringTestStruc(v map[string]TestStruc, e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
	} else if z.EncBasicHandle().Canonical {
		z.EncEncodeMapNonNil(v)
	} else {
		z.EncWriteMapStart(len(v))
		for yyk1, yyv1 := range v {
			z.EncWriteMapElemKey()
			r.EncodeString(string(yyk1))
			z.EncWriteMapElemValue()
			yy3 := &yyv1
			if yyxt4 := z.Extension(yy3); yyxt4 != nil {
				z.EncExtension(yy3, yyxt4)
			} else {
				yy3.CodecEncodeSelf(e)
			}
		}
		z.EncWriteMapEnd()
	}
}

func (x codecSelfer5629) decMapstringTestStruc(v *map[string]TestStruc, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyl1 := z.DecReadMapStart()
	if yyl1 == codecSelferDecContainerLenNil5629 {
		*v = nil
	} else {
		if yyv1 == nil {
			yyrl1 := z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 856)
			yyv1 = make(map[string]TestStruc, yyrl1)
			*v = yyv1
		}
		var yymk1 string
		var yymv1 TestStruc
		var yymg1, yymdn1 bool
		if z.DecBasicHandle().MapValueReset {
			yymg1 = true
		}
		if yyl1 != 0 {
			yyhl1 := yyl1 > 0
			for yyj1 := 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ {
				z.DecReadMapElemKey()
				yymk1 = (string)(z.DecStringZC(r.DecodeStringAsBytes()))
				if yymg1 {
					yymv1 = yyv1[yymk1]
				} else {
					yymv1 = TestStruc{}
				}
				z.DecReadMapElemValue()
				yymdn1 = false
				if yyxt4 := z.Extension(yymv1); yyxt4 != nil {
					z.DecExtension(&yymv1, yyxt4)
				} else {
					yymv1.CodecDecodeSelf(d)
				}
				if yymdn1 {
					yyv1[yymk1] = TestStruc{}
				} else {
					yyv1[yymk1] = yymv1
				}
			}
		} // else len==0: leave as-is (do not clear map entries)
		z.DecReadMapEnd()
	}
}

func (x codecSelfer5629) encSlicePtrtoTestStruc(v []*TestStruc, e *codec1978.Encoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for yyv1 := range v {
		z.EncWriteArrayElem()
		if v[yyv1] == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(v[yyv1]); yyxt2 != nil {
				z.EncExtension(v[yyv1], yyxt2)
			} else {
				v[yyv1].CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer5629) decSlicePtrtoTestStruc(v *[]*TestStruc, d *codec1978.Decoder) {
	var h codecSelfer5629
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*TestStruc{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*TestStruc, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*TestStruc, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(TestStruc)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*TestStruc, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}
